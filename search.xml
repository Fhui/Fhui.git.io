<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[探寻Android中MVP设计模式]]></title>
    <url>%2F2017%2F07%2F26%2F%E6%8E%A2%E5%AF%BBAndroid%E4%B8%ADMVP%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Android中mvp现在炙手可热的设计模式之一，在讲解mvp模式之前我们先看看图。此图是我从泡网上拔下来的，如果不可以这么做请联系我，我会删除的， 谢谢。 MVP是MVC升级来的， 如果有对MVC不了解的同学请自行百度， 我在这儿就说下MVC的缺点， android其实并没有标准的mvc模式， 而我们习惯性的把Activity当作Controller去使用， 而且在MVC中是允许M层和V层有交互的， 然而我们把一些逻辑写到controller中会使activitry或者fragment中代码巨多， 增加了代码的维护性，没准下一个开发者去维护代码是都要崩溃了下面我们进入今天的主题———-&gt;MVP在MVP中， 每个字母都代表着什么？因为它是从MVC升级而来， 所以除了P其余都相同 M:Module层， 也就是我们平常写的模型(JavaBean), 业务逻辑也是在这儿。 V:View层， Activity， 自定义的View等等 P:Presenter层，相当于中间人的角色，module去和view进行交互都是通过presenter 这样mvp三层已经介绍完了，当然它的优缺点也有很多，我就不在这儿一一列举的， 我们今天主要是学如何使用mvp。当然， 我们要以代码的形式体现，这次的代码就是简单的点击按钮展示json数据， url和以前我讲volley的一样， 都是获取经纬度，返回json数据，而网络请求用的是volley。volley是google在2013年推出的网络请求框架，有不懂得同学可以去看我的另一篇博客.下面我们首先来展示的就是Module层在下手之前我们要思考一下我们展示数据都需要什么， 首先展示数据是一个动作，所以我们定义一个接口showData， 然后里面写一个方法load, 它需要什么参数呢？我们展示数据其实就是请求网络接口，然后把它给我们返回的数据展示出来。所以我们需要一个url和一个加载数据的监听(接口)。 1234567public interface ILoadListener &#123; void loadSuccess(Data data); void loadError();&#125; 12345public interface IShowData &#123; Data load(String url, ILoadListener listener);&#125; 123456789101112131415161718192021222324public class LoadData implements IShowData&#123; private Data data; @Override public Data load(String url, final ILoadListener listener) &#123; HttpLoader.get(url, Data.class, 200, new ResponseListener() &#123; @Override public void onGetResponseSuccess(int requestCode, RBResponse response) &#123; data = (Data) response; listener.loadSuccess(data); &#125; @Override public void onGetResponseError(int requestCode, VolleyError error) &#123; listener.loadError(); &#125; &#125;, true); return data; &#125;&#125; 上文已经说过， 我是用的是volley+gson封装，返回的就是一个javabean， 所以很是方便。我们从代码中可以看到在监听成功的接口中是有参数的，为什么呢？继续往下看 下面我们展示view层。首先xml代码很是简单 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;Button android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:onClick=&quot;startLoad&quot; android:text=&quot;load&quot;/&gt; &lt;TextView android:id=&quot;@+id/tv_show_load_data&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:text=&quot;waiting for load data .&quot;/&gt;&lt;/LinearLayout&gt; 在加载数据的时候需要设置url, 然后加载成功了会做什么，加载失败或做什么，所以我定义了接口中有三个方法1234567public interface ILoadData &#123; String getUrl(); void successFor(Data data); void errorFor();&#125; 123456789101112131415161718192021222324252627282930313233343536public class LoadDataActivity extends AppCompatActivity implements ILoadData&#123; private String url = &quot;http://gc.ditu.aliyun.com/geocoding?a=苏州市&quot;; private TextView tv_show_load_data; private LoadPresenter loadPresenter = new LoadPresenter(this); @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_load); initView(); &#125; public void initView()&#123; tv_show_load_data = (TextView) findViewById(R.id.tv_show_load_data); &#125; public void startLoad(View view)&#123; loadPresenter.startLoad(); &#125; @Override public String getUrl() &#123; return url; &#125; @Override public void successFor(Data data) &#123; tv_show_load_data.setText(data+&quot;&quot;); &#125; @Override public void errorFor() &#123; tv_show_load_data.setText(&quot;load error .&quot;); &#125;&#125; 最后我们展示的是Prenenter层放出代码 1234567891011121314151617181920212223242526public class LoadPresenter &#123; private IShowData showData; private ILoadData loadData; public LoadPresenter(ILoadData loadData)&#123; this.loadData = loadData; showData = new LoadData(); &#125; public void startLoad()&#123; showData.load(loadData.getUrl(), new ILoadListener() &#123; @Override public void loadSuccess(Data data) &#123; loadData.successFor(data); &#125; @Override public void loadError() &#123; loadData.errorFor(); &#125; &#125;); &#125;&#125; 我们创建了先前的两个接口的实例，然后再构造器中初始化， 然后写一个load方法来供module和view层进行数据交互。到此为止， mvp版的展示数据就已经写完了，有的同学就说了，好麻烦啊， 仅仅是一个展示数据就写如此多的接口，对，兄弟，你说对了，就是比较麻烦，但是总比一个类上千行爽吧？这样层次分明，但是写起来要费一些时间，如果你有充分的时间和人力，并且提高代码的可维护性，mvp模式确实是挺好的选择，另外推荐下retrofit2+rxjava+mvp会让你一直高潮的，有兴趣的同学了解下吧。]]></content>
      <tags>
        <tag>Design pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于ListView数据显示错乱的解决方案]]></title>
    <url>%2F2017%2F07%2F26%2F%E5%85%B3%E4%BA%8EListView%E6%95%B0%E6%8D%AE%E6%98%BE%E7%A4%BA%E9%94%99%E4%B9%B1%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%20%2F</url>
    <content type="text"><![CDATA[我们在平常开发Android中经常用到listview, 然而, 这个空间如果不进行优化的写法, 是非常吃内存的. 但是google在2013年IO大会上提出的viewholder写法显然已经是现在的优化标准了, 然而这个优化带来的烦恼也挺多的.首先使用viewholder优化其实就是复用的创建好的item, 然后如果我们在创建好的item上面现实图片或者是在条目上做一些操作显然BUG是挺多的, 比如:我们listview显示的item里面是从网络获取的图片, 那么我们用viewholder优化后, 滑动listview图片会错乱, 会闪烁; 再比如, 我们常见的点赞操作, 我点击某一个条目, 它会给该条目设置一个标识, 然后当我在滑动的时候, 你会发现很奇怪, 怎么下面的item也会有该标识. 所以我们为了让listview做到尽量节约内存, 我们还是使用这个优化方案, 反之, 他出现的bug也要解决掉. 如果是网络请求获取图片显示在listview上面, 我们可以设置标签, 也就是tag, 可以使用他的URL来做他的标签, 然后加一个 if, else判断, 假如我们要在item上面做一些操作, 比如加载的是本地的图片, 假设我现在点击listview的条目, 要在条目上显示一个图片 类似于空间微信点赞操作, 那么我们应该怎么做? 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100package com.himan.blogdemo;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.view.ViewGroup;import android.widget.BaseAdapter;import android.widget.ImageView;import android.widget.ListView;import android.widget.RelativeLayout;import android.widget.TextView;import org.w3c.dom.Text;import java.util.ArrayList;import java.util.List;public class MainActivity extends AppCompatActivity &#123; private ListView lv_test; private List&lt;CheckBean&gt; strList; private StrListAdapter adapter; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); lv_test = (ListView) findViewById(R.id.lv_test); strList = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 100; i++) &#123; strList.add(new CheckBean(false, &quot;item&quot;+i)); &#125; adapter = new StrListAdapter(); lv_test.setAdapter(adapter); &#125; class StrListAdapter extends BaseAdapter &#123; ViewHolder holder; @Override public int getCount() &#123; return strList.size(); &#125; @Override public Object getItem(int position) &#123; return strList.get(position); &#125; @Override public long getItemId(int position) &#123; return position; &#125; @Override public View getView(final int position, View convertView, ViewGroup parent) &#123; if (convertView == null) &#123; convertView = View.inflate(MainActivity.this, R.layout.list_item_layout, null); holder = new ViewHolder(convertView); convertView.setTag(holder); &#125; else &#123; holder = (ViewHolder) convertView.getTag(); &#125; final CheckBean bean = strList.get(position); if(bean.isClick())&#123; holder.iv_check.setVisibility(View.VISIBLE); &#125;else&#123; holder.iv_check.setVisibility(View.GONE); &#125; holder.tv_content.setText(strList.get(position).getStr()); holder.rl_items.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; bean.setClick(!bean.isClick()); notifyDataSetChanged(); &#125; &#125;); return convertView; &#125; &#125; class ViewHolder &#123; TextView tv_content; ImageView iv_check; RelativeLayout rl_items; public ViewHolder(View view) &#123; tv_content = (TextView) view.findViewById(R.id.tv_content); iv_check = (ImageView) view.findViewById(R.id.iv_check); rl_items = (RelativeLayout) view.findViewById(R.id.rl_items); &#125; &#125;&#125; 这个是MainActivity代码, List的类型正是我创建的bean类的类型 1234567891011121314151617181920212223242526272829303132package com.himan.blogdemo;/** * Created by HIMan on 2016/10/4. */public class CheckBean &#123; private boolean isClick; private String str; public CheckBean(boolean isClick, String str) &#123; this.isClick = isClick; this.str = str; &#125; public String getStr() &#123; return str; &#125; public void setStr(String str) &#123; this.str = str; &#125; public boolean isClick() &#123; return isClick; &#125; public void setClick(boolean click) &#123; isClick = click; &#125;&#125; 在convertView里面做判断的时候有if同时也要有else, 这样不会有bug也会更严谨一些, 另外如果加载网络图片的话使用第三方库好多都有带防止图片错乱机制, 如果没有的话, 我们直接可以setTag(), 然后在根据getTag()来判断刚才的tag值, 可以用URL作为tag, 用法上大同小异. ——-代码下载——–]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Volley以及自定义Request详解]]></title>
    <url>%2F2017%2F07%2F26%2FVolley%E4%BB%A5%E5%8F%8A%E8%87%AA%E5%AE%9A%E4%B9%89Request%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[google在2013年I/O大会上发布了volley, 主打频繁的网络通信(小请求)。 本身Android就提供了HttpClient和HttpUrlConnection来进行网络请求，可是随着需求不断的提升，比如增加缓存啊，就变得更加复杂了，当然除了volley还有其他很多的优秀的网络请求。比如：OkHttp， Retrofit，xutils等等。当然，今天我们的主题还是volley。 volley:https://android.googlesource.com/platform/frameworks/volley下载volley然后导入添加依赖就好了。 volley提供了四种请求方式:StringRequest , JsonObjectRequest, JsonArrayRequest, ImageRequest.首先，我们在使用volley的时候先创建一个请求队列RequestQueue RequestQueue queue = Volley.newRequestQueue(this) 还要添加网络权限 &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt; #StringRequest StringRequest 字符串请求，其实用起来很简单。 StringRequest stringRequest = new StringRequest(int method, String url, Listener&lt;String&gt; listener, Response.ErrorListener errorListener); StringRequest中有两个构造参数， 其实就多了一个请求方式（int method）要么就是post请求， 要么就是get请求。其他的参数依次是:url地址, 请求成功监听，请求失败监听。下面为了更直观，我就找了一个查询经纬度接口的url做测试，代码如下: StringRequest stringRequest = new StringRequest(url, new Response.Listener&lt;String&gt;() { @Override public void onResponse(String s) { LogUtils.i(&quot;info:&quot;+s); } }, new Response.ErrorListener() { @Override public void onErrorResponse(VolleyError volleyError) { LogUtils.i(&quot;error infos :&quot; + volleyError.toString()); } }); queue.add(stringRequest); 代码很简单，就是创建一个StringRequest，然后两个回调，最后将该请求添加到请求队列中。下面我在给大家演示一遍StringRequest的post请求。 StringRequest stringRequest = new StringRequest(url, new Response.Listener&lt;String&gt;() { @Override public void onResponse(String s) { LogUtils.i(&quot;info:&quot;+s); } }, new Response.ErrorListener() { @Override public void onErrorResponse(VolleyError volleyError) { LogUtils.i(&quot;error infos :&quot; + volleyError.toString()); } }){ @Override protected Map&lt;String, String&gt; getParams() throws AuthFailureError { return map; } }; queue.add(stringRequest); 当发起post请求的时候，会调用父类getParams()方法来查找参数，我们看到参数返回的是一个map类型的，我们只需要重写该方法，然后添加map集合参数即可。 #JsonObjectRequest JsonObjectRequest与JsonArrayRequest没有什么实质性的区别，都是请求json数据，无非一个是json对象，另外一个是json数组罢了， 为了节约时间，我就给大家演示JsonObjectRequest。 public JsonObjectRequest(int method, String url, JSONObject jsonRequest, Listener&lt;JSONObject&gt; listener, ErrorListener errorListener) JsonObjectRequest在new的时候看起来和StringRequest基本类似，只不过多了一个请求参数json对象。 JsonObjectRequest jsonObjectRequest = new JsonObjectRequest(url, null, new Response.Listener&lt;JSONObject&gt;() { @Override public void onResponse(JSONObject jsonObject) { LogUtils.i(&quot;info:&quot;+jsonObject.toString()); } }, new Response.ErrorListener() { @Override public void onErrorResponse(VolleyError volleyError) { LogUtils.i(&quot;error infos :&quot; + volleyError.toString()); } }){ @Override protected Map&lt;String, String&gt; getParams() throws AuthFailureError { return map; } }; queue.add(jsonObjectRequest); 因为笔者没有找到传递json的接口，所以使用map代替，但是如果有这方面需求，其实同理， 就不需要重写父类的getParams()方法，直接将json对象作为一个参数传入方法中即可。JsonArrayRequest同理。volley使用就是这么简单，基本都是首先创建请求队列—-&gt;创建请求方式—–&gt;添加到请求队列 #ImageRequest 其实使用volley请求图片有三种，我这边介绍两种，一种是ImageRequest, 另外一种是ImageLoader ###ImageRequest ImageRequest imageRequest = new ImageRequest(url, new Response.Listener&lt;Bitmap&gt;() { @Override public void onResponse(Bitmap bitmap) { iv_show_pic.setImageBitmap(bitmap); } }, 0, 0, Bitmap.Config.RGB_565, new Response.ErrorListener() { @Override public void onErrorResponse(VolleyError volleyError) { LogUtils.i(&quot;error infos :&quot; + volleyError.toString()); } }); queue.add(imageRequest); 我们首先看到ImageRequest需要传入的构造参数, 其中除了第三四五个参数或许有些不明白，其余的都和上面讲的类似，其中第三个和第四个参数就是获取到图片的宽高，写多少就是会压缩到多少，如果写0的话就是不压缩，直接显示出来，然后第五个就是图片的格式。 ###ImageLoader ImageLoader imageLoader = new ImageLoader(queue, new ImageLoader.ImageCache() { @Override public Bitmap getBitmap(String s) { return null; } @Override public void putBitmap(String s, Bitmap bitmap) { } }); ImageLoader.ImageListener imageListener = ImageLoader.getImageListener(iv_show_pic, R.mipmap.ic_launcher, R.mipmap.ic_launcher); imageLoader.get(url, imageListener, 300, 100); ImageLoader的底层其实还是ImageRequest, 但是它比ImageRequest更有趣，为什么这么说呢？因为它添加了缓存功能，在当new ImageLoader的时候传入两个参数，一个是请求队列，另外一个是ImageCache（图片缓存）。图片缓存是怎么做的呢？其实图片缓存技术就是二级缓存。它的缓存过程就是缓存到本地，在下次请求的时候本地查找，没有在请求网络，其中有两个算法，LruCache和DiskLruCache算法，有兴趣的同学可以去查查，毕竟这不是我们的主题嘛。 好啦，Volley最基础的用法已经学完啦，so easy不是吗然而难道每次请求都需要 写这么多代码么？其实这也是volley的有点，可扩展性强。哈哈。大家可以脑补下。因为接下来到高潮了。 #自定义Reuqest 大家在平时开发中post请求接口无非就是两种方式嘛，一种请求提示map，另外就是json，然而服务器返回的也大多是两种，一种xml, 一种json。然而现在大多数都是json咯。何为自定义Reqeust？就是自己写一个Reuqest，此处容我笑两声![这里写图片描述](http://img.blog.csdn.net/20160518173036141) 首先我们来做第一种，服务器返回的是json数据，我们开发时都知道Gson可以解析json数据，所以我们将Request和Gson封装一起，那岂不是爽死了？为了个Gson封装一起 我们先一个javabean的基类，然后解析的时候更方便。 首先我们创建一个类来集成Reqeust泛型类，在里面初始化Gson并且重写里面的parseNetworkResponse(), deliverResponse(), 其实我们在手写自定义Reqeust的时候要扒一下源码，我们会发现都会有parseNetworkResponse()方法，so…我们发现这个方法的重要性，处理网络请求。所以我们的主要实现还是在这里完成 try { String json = new String( response.data, HttpHeaderParser.parseCharset(response.headers)); Log.i(&quot;GsonRequest&quot;, &quot;content&quot;+json); T result = null; try { result = gson.fromJson(json, clazz); //解析json if (isCache) { FileCopyUtils.copy(response.data, new File(MobileApplication.application.getCacheDir(), &quot;&quot; + MD5Utils.encode(getUrl()))); } } catch (JsonSyntaxException e) { result = (T) gson.fromJson(json, ErrorResponse.class);//解析失败，按规范错误响应解析 } catch (IOException e) { e.printStackTrace(); } return Response.success( result, HttpHeaderParser.parseCacheHeaders(response)); } catch (UnsupportedEncodingException e) { return Response.error(new ParseError(e)); } catch (JsonSyntaxException e) { return Response.error(new ParseError(e)); } 这样基本我们自定义Request完成了，然后我们要写一个网络请求类来封装Request。然后根据刚刚自定义Request的构造器来创建一个，代码如下 private static Request makeGsonRequest(int method, String url, Map&lt;String, String&gt; params, Class&lt;? extends RBResponse&gt; clazz, int requestCode, ResponseListener listener, boolean isCache) { HttpListener httpListener = new HttpListener(listener, requestCode, mInFlightRequests); GsonRequest gsonRequest = new GsonRequest&lt;RBResponse&gt;(method, url, params, clazz, httpListener, httpListener, isCache); gsonRequest.setRetryPolicy(new DefaultRetryPolicy()); return gsonRequest; } 在这儿出现了一个陌生的方法 setPetryPolicy(); 这个方法是设置超时时间，这儿是写死的，但是有的需求或许长一点，比如服务器需要一个比较复杂的运算过程，那么这个超时时间就得设置长一点。这个方法就是单步封装了刚刚自定义Request里面的代码显而易见的，而还有一个HttpListener， HttpListener封装的请求的监听，里面只有成功失败，传入的是listener, 请求码(稍后再说)， 和一个map(稍后再说)。 自定义Request创建完成了，下面应该还有一层封装，为什么呢？因为volley之所以方便，它可以根据每个请求设置一个请求码，正如刚才HttpListener中的构造一样，而我为什么还要写一个HashMap呢？因为我用HashMap来保存请求记录，它的键值对的类型是Integer, request看到类型是不是有种恍然大悟的感觉？所以我们在封装一个方法来请求自定义Request, 代码如下。 private static Request request(int method, String url, Map&lt;String, String&gt; params , Class&lt;? extends RBResponse&gt; clazz, int requestCode, ResponseListener listener, boolean isCache) { Request request = mInFlightRequests.get(requestCode); if (request == null) { request = makeGsonRequest(method, url + buildParams(params), null, clazz, requestCode, listener, isCache); tryLoadCacheResponse(request, requestCode, listener); return addRequest(request, requestCode); } else { return request; } 大家先看代码，传入的参数先不管，因为在自定义Reqeust的时候全部都有用到，它里面做了什么？首先map先查找了一下请求码，返回的是一个reqeust, 然后判断是否空，如果空则是一个新的请求，去创建自定义Request请求，在makeGsonRequest方法中有个方法 buildParams(), 这个方法主要就是拼接map字符串, 然后又看到一个陌生的方法，tryLoadCacheResponse(), 这个方法是什么，从字面的意思是尝试缓存网络，里面传了一个request请求，请求码， 监听，这个方法里面做了什么？看代码。 private static void tryLoadCacheResponse(Request request, int requestCode, ResponseListener listener) { if (listener != null &amp;&amp; request != null) { try { File cacheFile = new File(MobileApplication.application.getCacheDir(), &quot;&quot; + MD5Utils.encode(request.getUrl())); StringWriter sw = new StringWriter(); FileCopyUtils.copy(new FileReader(cacheFile), sw); if (request instanceof GsonRequest) { GsonRequest gr = (GsonRequest) request; RBResponse response = (RBResponse) gr.getGson().fromJson(sw.toString(), gr.getClazz()); listener.onGetResponseSuccess(requestCode, response); } } catch (Exception e) { } } } 这个方法主要就是将数据缓存到本地，先判断请求和监听是否为空，然后将请求的url通过MD5算法编译保存到本地，然后下次去的时候会有限匹配改请求的缓存，就是办了这个一个事。 最后我们直接在封装一成我们方便调用 public static Request post(String url, Map&lt;String, String&gt; params, Class&lt;? extends RBResponse&gt; clazz, final int requestCode, final ResponseListener listener, boolean isCache) { return request(Request.Method.POST, url, params, clazz, requestCode, listener, isCache); } 自此，自定义Request post带参map已经全部完成。但是有的哥们服务器响应的是json， 怎么办呢？这个更简单，只需要修改自定义Request就好了。直接放代码。为了方便我直接集成了JsonRequest protected Response&lt;T&gt; parseNetworkResponse(NetworkResponse response) { try { String json = new String(response.data, HttpHeaderParser.parseCharset(response.headers)); T result = null; try { result = gson.fromJson(json, clazz); if (isCache) { FileCopyUtils.copy(response.data, new File(MobileApplication.application.getCacheDir(), &quot;&quot; + MD5Utils.encode(getUrl()))); } } catch (JsonSyntaxException e) { result = (T) gson.fromJson(json, ErrorResponse.class); } catch (IOException e) { e.printStackTrace(); } return Response.success(result, HttpHeaderParser.parseCacheHeaders(response)); } catch (UnsupportedEncodingException e) { return Response.error(new ParseError(e)); }catch (JsonSyntaxException e){ return Response.error(new ParseError(e)); } } 典型的换汤不换药，其他基本一样，我在这么写一遍不是侮辱大家的智商么。最后使用的时候请求成功根据传入的泛型数据返回，然而我们将Gson一起封装里面了，so..爽不爽，然后我们直接get* 即可。 那好吧 就先这样了有什么问题留言撒]]></content>
      <tags>
        <tag>Library</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RXJava入门]]></title>
    <url>%2F2017%2F07%2F26%2FRXJava%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[现在RXJava可谓是赤手可热，没接触过的同学见了RXJava风格代码会不会吐槽？“TMD这个是什么？和屎一样”哈哈，我初次见反正吐槽了，看不明白什么意思，但是经过了解以后看到了它的魅力，简直是代码中的宋仲基啊。帅的一逼。 首先感谢抛物线大大谢了这么好的文章，供我们充分了解RXJava，原谅博主的愚笨看了好多遍,千万不要嘲笑朕，所以做一个笔记我们一起交流。…. 博主总结的或许还是不是那么容易全, 但是起到一个交流的作用，见谅。废话不多说，见正文。老规矩—–&gt;GIT:https://github.com/ReactiveX/RxJava ,——————&gt;https://github.com/ReactiveX/RxAndroid使用只需要添加依赖就好: 12compile &apos;io.reactivex:rxjava:1.0.14&apos;compile &apos;io.reactivex:rxandroid:1.0.1&apos; 其实说白了RXJava就是异步的代名词， 在Android上面，好多操作都必须是异步的， 在Android的主线程中不允许有过多的耗时操作，否则系统抛出ANR异常，是的，你的程序被系统抛弃了。 我们先来说说RXJava的关键API。 Observable: 被观察者，Observer: 观察者， subscribe : 绑定观察对，刚才忘了说了，其实这就是观察者模式，API也很直白，观察者，被观察者，订阅。一目了然。 ##创建Hello, world我们在学编程的时候首先就会写最最最基础的helloworld， 那么我先给大家吧RXJava版的HelloWorld写出来，让大家过目。 12345678910111213141516171819202122Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(Subscriber&lt;? super String&gt; subscriber) &#123; subscriber.onNext(&quot;hello, world.&quot;); subscriber.onCompleted(); &#125; &#125;).subscribe(new Observer&lt;String&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(String s) &#123; Log.i(TAG, &quot;onNext:&quot;+s); &#125; &#125;); 尼玛，我只不过输出依据hello,world竟然要这么多行，还让不让活了？看官，且听我慢慢讲解。上面代码就是举得最简单的例子，当然现实中写代码肯定不会这样的嘛，特么一个hello， world也要用rxjava写，除非你是RXJava骨灰粉丝，要不然你就是神经病，为了让大家容易快速掌握RXJava的使用用法，所以例子都会比较简单的。代码很容易理解，创建一个Observable然后实现OnSubcribe中的call方法，这个方法中的参数是Subscriber subscriber 那么subcriber是什么？它是Observer中内置的抽象类罢了，但是重点来了，每个subcriber都会被转成Observer来使用的，所以他们都可以实现功能只不过subcriber比Observer多了几个方法而已，所以写代码的时候可以直接写subcriber.当Observable被订阅的时候 自动触发call()然后通过onNext()来触发，最后调用onCompleted(), 然后再observer中的onNext()方法来展示结果。是不是特别简单？那么我们再来学习RXJava提供的另外几个更方便的APIObservable 12345678910111213141516Observable.just(&quot;hello&quot;, &quot;world&quot;).subscribe(new Observer&lt;String&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(String s) &#123; Log.i(TAG, &quot;onNext:&quot;+s); &#125; &#125;); 前面突然出现了just(…)方法，其实Observable.just(“hello”, “world”)就是等同于subcriber.onNext(“hello”);subcriber.onNext(“world”);subcriber.onCompleted();是不是简化了许多？还有一种是操作数组的方法from() 1234567891011121314151617String[] strArray = &#123;&quot;hello&quot;, &quot;world&quot;&#125;; Observable.from(strArray).subscribe(new Subscriber&lt;String&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(String s) &#123; Log.i(TAG, &quot;onNext:&quot;+s); &#125; &#125;); 操作起来都是一样的，非常的简单。好了，最基础的hello,world已经搞定了，下面我们继续搞一下filter， map， flatMap. ##flter, map, flatMap 首先我们来看看flter方法。flter翻译过来的意思是滤过，其实它在rxjava中的含义也差不多，过滤嘛。我们来写个Demo玩玩。 123456789101112131415161718192021222324String[] params = &#123;&quot;android&quot;, &quot;ios&quot;, &quot;java&quot;, &quot;c&quot;, &quot;c++&quot;&#125;; Observable.from(params) .filter(new Func1&lt;String, Boolean&gt;() &#123; @Override public Boolean call(String s) &#123; return s.length() &gt; 3; &#125; &#125;) .subscribe(new Subscriber&lt;String&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(String s) &#123; Log.i(TAG, &quot;onNext:&quot; + s); &#125; &#125;); 运行结果—–&gt;06-06 15:34:38.468 10201-10201/ALOG: onNext:android 06-06 15:34:38.468 10201-10201/ALOG: onNext:java 上面代码就是过滤params数组中字符串长度小于3的参数，然后再onNext方法中打印出来, 使用filter过滤是不是挺爽的。下面我们看看map， map可以起到变换的作用，超吊的哦。 1234567891011121314151617181920212223242526272829Observable.just(1, 2, 3, 4, 5) .filter(new Func1&lt;Integer, Boolean&gt;() &#123; @Override public Boolean call(Integer integer) &#123; return integer &gt; 3; &#125; &#125;) .map(new Func1&lt;Integer, String&gt;() &#123; @Override public String call(Integer integer) &#123; return integer+&quot;rxJava&quot;; &#125; &#125;) .subscribe(new Subscriber&lt;String&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(String s) &#123; Log.i(TAG, &quot;onNext:&quot;+s); &#125; &#125;); 打印的结果是: 1206-06 15:50:11.688 23667-23667/ALOG: onNext:4rxJava06-06 15:50:11.688 23667-23667/ALOG: onNext:5rxJava 从代码可以看出，首先just进去五个数字，然后通过filter过滤大于3的，然后再通过map把过滤后的添加字符串’rxjava’，在onNext方法打印输出.是不是map也是非常简单的，感觉到rxjava的强大了吧。我们再来看看flateMap 123456789101112131415161718192021222324252627282930313233Observable.create(new Observable.OnSubscribe&lt;Person&gt;() &#123; @Override public void call(Subscriber&lt;? super Person&gt; subscriber) &#123; subscriber.onNext(Person.createPerson()); &#125; &#125;).flatMap(new Func1&lt;Person, Observable&lt;Person.PersonProperty&gt;&gt;() &#123; @Override public Observable&lt;Person.PersonProperty&gt; call(final Person person) &#123; return Observable.create(new Observable.OnSubscribe&lt;Person.PersonProperty&gt;() &#123; @Override public void call(Subscriber&lt;? super Person.PersonProperty&gt; subscriber) &#123; for(int i = 0;i &lt; person.getList().size(); i++)&#123; subscriber.onNext(person.getList().get(i)); &#125; &#125; &#125;); &#125; &#125;).subscribe(new Subscriber&lt;Person.PersonProperty&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(Person.PersonProperty personProperty) &#123; Log.i(TAG, &quot;onNext:&quot;+personProperty); &#125; &#125;); 打印结果： 1234567891006-06 16:54:12.288 15529-15529/ALOG: onNext:PersonProperty&#123;sex=&apos;男&apos;, age=100, name=&apos;张三&apos;&#125;06-06 16:54:12.288 15529-15529/ALOG: onNext:PersonProperty&#123;sex=&apos;男&apos;, age=101, name=&apos;张三&apos;&#125;06-06 16:54:12.288 15529-15529/ALOG: onNext:PersonProperty&#123;sex=&apos;男&apos;, age=102, name=&apos;张三&apos;&#125;06-06 16:54:12.288 15529-15529/ALOG: onNext:PersonProperty&#123;sex=&apos;男&apos;, age=103, name=&apos;张三&apos;&#125;06-06 16:54:12.288 15529-15529/ALOG: onNext:PersonProperty&#123;sex=&apos;男&apos;, age=104, name=&apos;张三&apos;&#125;06-06 16:54:12.288 15529-15529/ALOG: onNext:PersonProperty&#123;sex=&apos;男&apos;, age=105, name=&apos;张三&apos;&#125;06-06 16:54:12.288 15529-15529/ALOG: onNext:PersonProperty&#123;sex=&apos;男&apos;, age=106, name=&apos;张三&apos;&#125;06-06 16:54:12.288 15529-15529/ALOG: onNext:PersonProperty&#123;sex=&apos;男&apos;, age=107, name=&apos;张三&apos;&#125;06-06 16:54:12.288 15529-15529/ALOG: onNext:PersonProperty&#123;sex=&apos;男&apos;, age=108, name=&apos;张三&apos;&#125;06-06 16:54:12.288 15529-15529/ALOG: onNext:PersonProperty&#123;sex=&apos;男&apos;, age=109, name=&apos;张三&apos;&#125; 其实我就是创建了一个javaBean， 然后打印姓名以及和这个人的属性， flatMap变换比较难理解，其实就是返回的是一个Obsverable对象，当创建一个Obsverable的时候，他会将里面的参数全部读取出来，然后统一发给Subcribe去打印，其实在上面的代码中我为了大家更容易理解我没有写Obsverable.from，而是利用for循环打印，这样更好理解，更容易看清变换的过程。 ##线程控制Scheduler Schedulers.immediate(): 直接在当前线程运行，默认。Schedulers.newThread(): 创建一个线程在新线程执行操作。Schedulers.io(): 其实就是里面含有一个无数量上限的线程池，可以重用空闲的线程。Schedulers.computation(): 一般进行复杂计算所使用的线程。AndroidSchedulers.mainThread():在主线程中运行。 ##结束语也是谢了不少内容，RXJava的基本内容反正是在这儿了，还有很多没有列举出来，大家可以多实践， 我们多多交流。 #共勉。]]></content>
      <tags>
        <tag>Library</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MaterialDesign设计风格之自定义toolbar的简单实现]]></title>
    <url>%2F2017%2F07%2F26%2FMaterialDesign%E8%AE%BE%E8%AE%A1%E9%A3%8E%E6%A0%BC%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89toolbar%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[MaterialDesign是Google在2014 I/O年发布的一种设计风格. android5.0也是开始使用这种设计风格英文文档：http://www.google.com/design/spec/material-design/中文网站：http://wiki.jikexueyuan.com/project/material-design/今天我们主要学习toolbar，还有Google提供的侧滑控件，DrawerLayout，顺带把Google提供的下拉刷新控件SwipeRefreshLayout举例说明下。 效果如下上图就是借用的代码家大神的api接口写了一个小demo。用的volley请求，添加缓存，imageloader图片加载，recycleview瀑布流，单一activity，fragment＋viewpager设计模式。有点跑题，有想要源码的可以取下面查看下载连接，交流学习开源为主。 因为toolbar是在v7包中，我们要添加依赖 1compile &apos;com.android.support:appcompat-v7:24.0.0&apos; 首先在自定义toolbar之前一定要把android自带的标题栏给隐藏掉，在theme里面添加行代码1&lt;item name=&quot;windowNoTitle&quot;&gt;true&lt;/item&gt; 然后单独写一个toolbar的布局，因为android自带的标题栏实在是丑爆了，怎么都不好搭配。于是乎，Google推出了设计风格，自定义toolbar，简直是凤姐变志玲啊。Google把toolbar放在了supportv7包里面，见代码。 1234567891011&lt;android.support.v7.widget.Toolbar xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:id=&quot;@+id/custom_toolbar&quot; android:background=&quot;@android:color/holo_green_dark&quot; android:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot; app:theme=&quot;@style/ThemeOverlay.AppCompat.ActionBar&quot;&gt;&lt;/android.support.v7.widget.Toolbar&gt; 然而一定要在style里面设置主题添加上toolbar的主题 12345678910&lt;!-- Base application theme. --&gt;&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.DarkActionBar&quot;&gt; &lt;!-- Customize your theme here. --&gt; &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorOrange&lt;/item&gt; &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/colorOrange&lt;/item&gt; &lt;item name=&quot;colorAccent&quot;&gt;@color/colorOrange&lt;/item&gt; &lt;item name=&quot;windowNoTitle&quot;&gt;true&lt;/item&gt; &lt;item name=&quot;android:textColorPrimary&quot;&gt;@android:color/white&lt;/item&gt;&lt;item name=&quot;drawerArrowStyle&quot;&gt;@style/AppTheme.DrawerArrowToggle&lt;/item&gt;&lt;/style&gt; 12345&lt;style name=&quot;AppTheme.DrawerArrowToggle&quot; parent=&quot;Base.Widget.AppCompat.DrawerArrowToggle&quot;&gt; &lt;item name=&quot;color&quot;&gt;@android:color/white&lt;/item&gt;&lt;/style&gt; 然后我们开始写DrawerLayout这个就比较简单了，我们可以作为根布局 1234567891011121314151617181920212223242526272829303132333435363738&lt;android.support.v4.widget.DrawerLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:id=&quot;@+id/dl_left&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;FrameLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;0dp&quot; android:layout_weight=&quot;1&quot;&gt; &lt;android.support.v4.view.ViewPager android:id=&quot;@+id/vp_home&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;/android.support.v4.view.ViewPager&gt; &lt;/FrameLayout&gt;&lt;/LinearLayout&gt; &lt;FrameLayout android:layout_width=&quot;280dp&quot; android:layout_height=&quot;match_parent&quot; android:id=&quot;@+id/fl_left&quot; android:layout_gravity=&quot;left&quot; android:background=&quot;@android:color/white&quot;&gt; &lt;/FrameLayout&gt;&lt;/android.support.v4.widget.DrawerLayout&gt; 这里我们要注意下，drawerlayout中侧滑的布局要放在后面，如果写到了侧滑的布局，要设置这个属性android:layout_gravity=&quot;left&quot;设置是哪边侧滑，也是一个标记。这样基本就搞定了，然后设置一些属性直接找到该空间，设置一些文字之类的。非常简单。当然也可以在style里面设置。是不是感觉非常的炫酷？下面说一下SwipeRefreshLayout官方提供的下拉刷新控件。这个控件是在v4兼容包里面。也可以作为根布局来使用，上代码。 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.v4.widget.SwipeRefreshLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:id=&quot;@+id/swip_layout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;ListView android:id=&quot;@+id/ganhuo_lv&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:divider=&quot;@null&quot; android:dividerHeight=&quot;10dp&quot; android:padding=&quot;5dp&quot;&gt; &lt;/ListView&gt;&lt;/android.support.v4.widget.SwipeRefreshLayout&gt; 在要下拉刷新的activity中实现这个监听接口 1SwipeRefreshLayout.OnRefreshListener 重写onRefresh方法，我是用的handler来更新的ui布局 123456@Overridepublic void onRefresh() &#123; Message msg = Message.obtain(); msg.what = 1; handler.sendMessage(msg);&#125; 里面可以做一些获取数据的操作啊，我这儿简单起见，并没有模拟。 1234567891011private Handler handler = new Handler()&#123; @Override public void handleMessage(Message msg) &#123; switch(msg.what)&#123; case 1: swip_layout.setRefreshing(false); break; &#125; super.handleMessage(msg); &#125; &#125;; 用起来也是特别的简单，而且这个下拉刷新控件还支持设置不同的颜色 12swip_layout.setColorSchemeResources(android.R.color.holo_blue_light, android.R.color.holo_orange_dark, android.R.color.holo_green_light, android.R.color.holo_red_dark); 最后，有想看源码的可以戳此连接，https://github.com/Fhui/GankApp个人网站：http://nexthiman.com]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac上使用Hexo+github搭建自己的博客]]></title>
    <url>%2F2017%2F07%2F26%2FMac%E4%B8%8A%E4%BD%BF%E7%94%A8Hexo%2Bgithub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[推荐大家购买一个域名，这样使用起来方便的多。购买域名有好多种方式，为了避免冲突，大家自行购买。另外博主使用的是mac，所以，今天的教程主题是mac系统，不过windows系统大同小异，原理是一样的，只不过Mac集成了不少环境，变得更方便。因为hexo基于node.js, 所以我们直接下载nodejs。当然也得下载Git, 因为我们是结合Github吗，所以工具是少一不可。 安装好，开始安装hexo，控制台－－&gt; sudo npm install -g hexo 自动安装找一个比较显著的位置建立一个文件夹, 楼主是强迫症，所以在applications里面创建的文件夹 1cd /applications/hexo 进入这个hexo文件夹目录下，然后hexo init 初始化hexo，它会生成一大堆静态网站文件。 这时候在hexo server 它会给你一个ip地址，然后你直接copy到浏览器访问就能看到欢迎页面”hello world”了 接着输入－－&gt; hexo init最好在写一下这个指令－－&gt; npm install hexo-deployer-git --save 为了防止最后部署到Github上面的时候出现 Deployer not found: github或者部署到服务器的时候出现错误所以最好搞一下。 好了，这个时候我们基本搞好了，其他的都先不管，我们先部署到Github上再说。前方高能预警！首先我们登录Github登录成功后点击创建一个新的仓库输入仓库名以及描述，接着创建成功。好，我们此时再回到终端创建私钥与我们创建的远程仓库进行关联。我们首先输入cd ~/.ssh看看是否有安装过这个ssh私钥如果没有会提示没有找到文件。其中会让你输入一次密码，四位数以上的，谨记，以后会用到。接着输入ssh-keygen -t rsa -C &quot;email&quot;然后它会出现这个 1Enter file in which to save the key (/Users/HIMan/.ssh/id_rsa): 就是询问你的ssh保存到哪儿，以及让你输入你的id_rsa，你可以自定义id_rsa但是最好不要改变路径，要不然后面会变得特别恶心。好了，然后打开Finder找到保存的公钥，然后打开Github仓库，点击setting，然后创建一个ssh， 然后吧公钥的内容复制进去。这时候已经连接成功。现在回到Github打开我们创建的仓库，点击设置，找到Github pages选项，然后点击大按钮然后选择一个内容体，点击create然后选择主题点击publish page这时候我们就生成完毕了。然后Github会给我们自动创建一个分支这时候我们在gh-pages里面打开设置，我们可以看到Github page已经创建完成，并且给我们生成了这个连接。到此为止我们的Github page已经创建完成。这时候我们再来到hexo。打开终端输入指令hexo generate会生成一套静态网页，在你创建hexo的文件夹下面生成了一个public文件夹，里面全部都是静态网页文件。这时候我们创建一个文件夹作为Github的仓库。博主用的不是命令而是sourcetree，比较简单，然后我们打开sourcetree， 创建新仓库，选择添加已存在的本地仓库路径就写你仓库的路径，然后创建完毕后打开，点击设置，将Github上的ssh地址拿到，然后创建远程仓库，将此ssh地址输进去即可。这时候把刚才创建的public 文件夹下的文件全部复制进去，然后更新－－推送。如果出错那就是sourcetree没有关联此ssh, 那么我们重新写命令关联。 1ssh-add ~/.ssh/ID_rsa 后面跟着的就是你创建的ssh然后推送上去，这时候在访问Github给你提供的地址就是你创建的这个hexo的index了。现在再来说说绑定域名的问题。域名可以在好多地方买到，我感觉最好不要在国外的网站买，怕不怕被墙？我选的是dnspod，进入官网需要注册一个，然后在里面购买一个域名，点击域名解析，如果你购买了域名它会自动给你创建，如果没有活着在别的途径购买点击添加域名即可，很简单。然后点击添加记录，@ A 192.30.252.153 @ A 192.30.252.154 www CNAME *.github.io添加这三个地址，然后我们在回到Github里面找到我们的这个仓库，创建一个文件就叫CNAME，里面就写我们创建的域名即可。 然后漫长的等待－－－－－－－－－－－－－－－ 等待解析完毕，就可以访问试试看了。]]></content>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gradle多环境配置]]></title>
    <url>%2F2017%2F07%2F26%2FGradle%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[在开发中遇到了多个不同的环境, 比如测试环境, 上线环境, 甚至根据不同开发组有多个环境, 平常做法就是建一个类来存储, 然后在里面不停的注释来达到切换环境的效果, 其实gradle提供了多环境配置, 配置起来也挺简单的, 也不用之前的无脑注释了.首先打开自己的gradle, 在buildType里面有当前的两个环境, 一般都是debug环境和replace环境, 如果我们需要两个环境, 比如Test环境和上线环境, 我们只需要在BuildType里面去添加自己所需要的环境即可 123Test &#123; buildConfigField &apos;String&apos;, &apos;Base_URL&apos;, &apos;&quot;http://192.168.1.1&quot;&apos;&#125; 如果有多个环境的话另起一行即可, 这时候gradle会自动编译一下, 但是如果你的app没有打包配置的话会报错, 错误原因就是没有进行打包签名, 这时你只需要点这里进行打包操作, 生成自己应用的签名即可, 然后再点击这儿来配置你刚刚生成的key-store即可具体就是signing栏里面去添加一个配置, 配置好打开BuildType栏里面选择你刚刚配置的环境, 点击signing config去选择你刚刚配置的key即可一定要每个都要去配置, 不然还是会报和刚才相同的错误, 找不到key这时候基本就配置好了, 你只需要在BuildVariants里面选择不同的环境即可都配置好以后, 它默认会在你配置的module里面生成一个buildConfig文件, 里面就是你刚刚配置的环境目录:build—–&gt;generate—–&gt;source—–&gt;buildConfig—–&gt;Test—-&gt;BuildConifg.java Test就是我刚才配置的环境名字,这时候就方便的很了, 我们只需要在工程里面buildConfig.Base即可如果需要更换环境, 在BuildVariants更改即可.]]></content>
      <tags>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EventBus消息类型重复解决方案]]></title>
    <url>%2F2017%2F07%2F26%2FEventBus%E6%B6%88%E6%81%AF%E7%B1%BB%E5%9E%8B%E9%87%8D%E5%A4%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%20%2F</url>
    <content type="text"><![CDATA[我们平常在开发中各个组件进行数据交互也是常有的事，EventBus很好的解决了我们平常各组件数据交互时的代码量，但是我们在使用的时候会发现，如果每个页面发送的都是String类型的，在想接收的页面上接收也是String类型的，那么它会全部接收到，所以需要加一个判断，下面演示下解决方案吧，当然还有好多，另外还有很多类似于EventBus这种开源库，RXJava等等。 EventBus在V1.0.4的时候发布粘性事件，可以发送对象，但是需要手动注销掉。所以我们借助这个粘性事件来搞起。 我们首先创建一个Event类来存储信息 public T data; public Message msg; public static enum Message{ test; } public AppEvent(){ } public AppEvent(Message msg, T data){ this.msg = msg; this.data = data; } public Message getMessage() { return msg; } public &lt;T&gt;T getData(){ if(data == null){ } return (T)data; } public static &lt;T&gt; void post(Message msg, T data){ EventBus.getDefault().postSticky(new AppEvent(msg, data)); } 我们放入一个枚举类， 里面存储一些信息，然后我们发送的时候直接发送该类的post方法，然后接收onEvent(Appevent event), 然后通过message来switch判断，简单方便便捷。说白了就是加个判断呗。简单记录下。]]></content>
      <tags>
        <tag>Library</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android适配--dimen]]></title>
    <url>%2F2017%2F07%2F26%2FAndroid%E9%80%82%E9%85%8D--dimen%2F</url>
    <content type="text"><![CDATA[我发现网上关于socket的库介绍比较少啊，难道socket太简单了，大家不喜欢做？哈哈哈 我给大家推荐一个socketclient库，用起来特别方便，主要是源于前几天公司需要长连接，正好逛GitHub的时候发现的这个库，挺爽挺方便的，推荐给大家。 git:https://github.com/vilyever/AndroidSocketClient 下载完导入，然后再gradle中添加 repositories { maven { url &quot;https://jitpack.io&quot; } } dependencies { compile &apos;com.github.vilyever:AndroidSocketClient:1.4.1&apos; } 至于用法也是非常简单 private SocketClient socketClient; 创建scoketClient. socketClient = new SocketClient(url, prot); 里面传入socketClient的url地址和端口号。 socketClient.registerSocketDelegate(new SocketClient.SocketDelegate(){ @Override public void onConnected(SocketClient client) { socketClient.send(&quot;hello, server !---------------------------&gt;Android&quot;); socketClient.setHeartBeatMessage(&quot;hello, server !---------------------------&gt;Android&quot;); } @Override public void onDisconnected(SocketClient client) { Log.i(&quot;Server&quot;, &quot;timeout&quot;); String error = client.getCharsetName(); Log.i(&quot;Server&quot;, &quot;timeoutData:&quot;+error); } @Override public void onResponse(SocketClient client, @NonNull SocketResponsePacket responsePacket) { String responseMsg = responsePacket.getMessage(); int i = 1; Log.i(&quot;Server&quot;, responseMsg); } }); 这个方法直接实现了socket发送信息到服务器，在onDisconnected()错误信息也可以及时返回并打印。 socketClient.setConnectionTimeout(1000 * 15); socketClient.setHeartBeatInterval(1000); socketClient.setRemoteNoReplyAliveTimeout(1000 * 60); socketClient.setCharsetName(&quot;UTF-8&quot;); socketClient.connect(); 这边设置的是超时时间，心跳包的间隔， 自动连接时间，编码格式。是不是用起来特别爽？因为库也是国人写的，注释都是中文，大家可以扒一扒源代码看如何实现， 毕竟学东西不只是学如何使用，还要追求原理的。]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android初识BLE4.0]]></title>
    <url>%2F2017%2F07%2F26%2FAndroid%E5%88%9D%E8%AF%86BLE4.0%20%2F</url>
    <content type="text"><![CDATA[随着时代的发展，我们用到蓝牙的地方越来越多，android也从api18开始支持BLE4.0, 今天博客的主题就是BLE4.0，主要就是介绍如何使用以及运作的流程。在蓝牙方面的资料，还是比较少的，我感觉android对于蓝牙封装上面还是不是很友好。希望以后会改进吧，对于这样，我们只能打开官方文档查阅资料了。 打开bluetooth包，我们可以看到这个包是从API5添加进去的，然后就是Google对其的一番介绍，现在分为经典蓝牙和低功耗蓝牙(BLE4.0), 然而现在都是BLE4.0，所以我们直接去看BLE4.0.大概就是低功耗蓝牙是从api18开始添加进去的，可以用于一些设备的使用…提供了一些概念的介绍首先在使用蓝牙之前需要在清单文件中添加权限 12&lt;uses-permission android:name=&quot;android.permission.BLUETOOTH&quot;/&gt;&lt;uses-permission android:name=&quot;android.permission.BLUETOOTH_ADMIN&quot;/&gt; 然后Google给我们提供了关键类的查看我们先来看BluetoothAdapter这个类就是ble连接主要大类之一，好多关键操作都在这个类中进行操作。官方给的描述就是这是一个蓝牙适配器。可以实例化bluetoothDevice和BluetoothSocket下面我来介绍下如何使用:在使用BLE4.0之前最好友好的检查一下蓝牙是否可用，是否支持BLE4.0设备。 1234567891011/** * 设备是否支持BLE4.0 * @time 2016/6/17 0017 10:59 */public boolean judgeBuletooh() &#123; if (!getPackageManager().hasSystemFeature(PackageManager.FEATURE_BLUETOOTH_LE)) &#123; return false; &#125; else &#123; return true; &#125;&#125; 123456789101112131415161718//检查是否支持BLE4.0 if (!judgeBuletooh()) &#123; Toast.makeText(context, &quot;您的设备不支持ble4.0&quot;, Toast.LENGTH_SHORT).show(); finish(); &#125; //检查是否支持蓝牙 if (bluetoothAdapter == null) &#123; Toast.makeText(context, &quot;您的设备不支持bluetooth&quot;, Toast.LENGTH_SHORT).show(); finish(); return; &#125; //开启蓝牙 bluetoothAdapter.enable(); bluetoothLe = new MyBluetoothLe(this); if (!bluetoothLe.initialize()) &#123; Toast.makeText(context, &quot;初始化MyBluetoothLe失败&quot;, Toast.LENGTH_SHORT).show(); finish(); &#125; 获取bluetoothAdapter有两种途径 1bluetoothManager = (BluetoothManager) getSystemService(Context.BLUETOOTH_SERVICE); 1bluetoothAdapter = bluetoothManager.getAdapter(); 这样就获得了bluetoothAdapter了，然后我们就可以开启蓝牙了 1bluetoothAdapter.enable(); 开启蓝牙后扫描设备 1bluetoothAdapter.startLeScan(LeScanCallback callback); 扫描设备，里面穿了一个参数LeScanCallback, 我们去文档上找找这是个什么东西。官方文档上显示回调接口用来实现扫描结果。显而易见，那么我们就写一个LeScanCallback 12345private BluetoothAdapter.LeScanCallback leScanCallback = new BluetoothAdapter.LeScanCallback() &#123; @Override public void onLeScan(final BluetoothDevice device, final int rssi, final byte[] scanRecord) &#123; &#125;); 重写了LeScanCallback实现了里面的onLeSean方法，让我们看看这些参数都是什么，第一个就是扫描到的设备，第二个就是蓝牙的rssi值，这个值就是测试蓝牙设备与终端的距离，第三个就是扫描的设备提供的内容，这时候我们可以创建一个集合了，然后添加进去，将扫描的设备动态的显示出来。我们扫描的做好了，那么我们应该找到了设备准备进行连接了。需要连接首先是要找到要连接的设备的，这个设备是BluetoothDevice类型的，我们再来看看文档上对这个类的说明。官方的意思就是说这代表着一个远程的蓝牙设备，你可以获取它的信息。等等等…它有一个getAddress() 方法就是获取地址值然后我们再看BluetoothDevice提供的连接方法传入一个上下文，是否自动连接，以及一个BluetoothGattCallback回调我们再来看看BluetoothGattCallback回调官方解释：这是一个抽象类用来实现BluetoothGatt回调我们来写一个BluetoothGatt 123456789101112131415161718192021222324252627282930313233343536373839private BluetoothGattCallback gattCallback = new BluetoothGattCallback() &#123; @Override public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) &#123; if(newState == BluetoothProfile.STATE_CONNECTED)&#123; &#125;else if(newState ==BluetoothProfile.STATE_DISCONNECTED)&#123; &#125;else if(newState == BluetoothProfile.STATE_CONNECTING)&#123; &#125;else if(newState == BluetoothProfile.STATE_DISCONNECTING)&#123; &#125; &#125; &#125; @Override public void onServicesDiscovered(BluetoothGatt gatt, int status) &#123; &#125; @Override public void onCharacteristicRead(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) &#123; &#125; @Override public void onCharacteristicWrite(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) &#123; &#125; @Override public void onCharacteristicChanged(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic) &#123; &#125; @Override public void onDescriptorWrite(BluetoothGatt gatt, BluetoothGattDescriptor descriptor, int status) &#123; &#125;; 重写了辣么多方法，看着真恐怖哈，其实每个方法都很重要，慢慢解释。 public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) {这个说白了就是监听蓝牙的状态的，我上面吧一些状态写出来了，直接用newState判断即可。 1public void onServicesDiscovered(BluetoothGatt gatt, int status) 这个方法就是发现服务后的回调 1public void onCharacteristicRead(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) 这个方法就是读取特征操作的结果回调 1public void onCharacteristicWrite(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) 这个方法就是写入特种操作结果回调 1public void onCharacteristicChanged(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic) 这个方法就是特征发生改变的时候回调 1public void onDescriptorWrite(BluetoothGatt gatt, BluetoothGattDescriptor descriptor, int status) 这个方法就是对这个描述符号写操作的回调这里面每个方法都有一个共同的参数就是BluetoothGatt我们再来看一看这个类是干什么的。Google说这个类提供了启动蓝牙连接设备，发现设备，以及扫描过程我们可以在onConnectionStateChange 查看蓝牙的状态并作出相应的操作，写入特征与读取都可以在对应的方法中写出业务逻辑即可。记得连接成功后一定要关闭扫描。另外，当断开后再立马开始扫描会容易使蓝牙崩溃掉，还有Google提供的蓝牙自动连接并不稳定，节省资源再对应的生命周期方法中关闭掉蓝牙停止扫描。]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android事件的分发(二)]]></title>
    <url>%2F2017%2F07%2F26%2FAndroid%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%88%86%E5%8F%91(%E4%BA%8C)%20%2F</url>
    <content type="text"><![CDATA[这是Android事件分发讲解的第二篇， 在上篇我讲过View的事件分发，感兴趣的或者没有看过的可以再去温习一遍。一定要有不屈的精神， 哈哈。 今天我们来搞下ViewGroup的事件分发，这个博主感觉要比View事件分发复杂一点点，但是也不难。 #ViewGroup 上篇博客我们在讲View的事件分发的时候讲过了， 当手指触摸屏幕的时候肯定会调用dispathTouchEvent方法，那么View和ViewGroup有什么区别？我简要的说下，我们所有能看得到的控件都是直接或间接的继承自View, 比如Button，TextView等等，太多了。那么ViewGroup是什么？说白了我们常用的布局都是继承自ViewGroup, LinearLayout, RelativeLayout， 那么，当我们用到写自定义控件的时候， 感觉会更强烈， 自定义View和自定义ViewGroup, 好， 那么我们先来看看ViewGroup是如何事件分发的？ 1234567891011121314151617181920&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;Button android:id=&quot;@+id/btn_test&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;test_onTouch&quot; android:layout_centerInParent=&quot;true&quot;/&gt; &lt;com.customview.CustomViewGroup android:id=&quot;@+id/custom_group&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:clickable=&quot;true&quot;&gt; &lt;/com.customview.CustomViewGroup&gt;&lt;/LinearLayout&gt; 这是目前的布局， customViewGroup是一个自定义的LinearLayout, 间接继承了ViewGroup， 里面目前没有包含任何的View， 下面见代码 12345678910111213public class CustomViewGroup extends LinearLayout &#123; public CustomViewGroup(Context context) &#123; super(context); &#125; public CustomViewGroup(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; public CustomViewGroup(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class MainActivity extends AppCompatActivity &#123; private static final String TAG = &quot;ALOG&quot;; @BindView(R.id.btn_test) public Button btn_test; @BindView(R.id.custom_group) CustomViewGroup custom_group; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ButterKnife.bind(this); &#125; @OnClick(&#123;R.id.btn_test,R.id.custom_group&#125;) public void click(View v)&#123; switch(v.getId())&#123; case R.id.btn_test: Log.i(TAG, &quot;Button:onclick&quot;); break; case R.id.custom_group: Log.i(TAG, &quot;viewGroup:onclick&quot;); break; &#125; &#125; @OnTouch(&#123;R.id.btn_test,R.id.custom_group&#125;) public boolean touch(View v, MotionEvent event)&#123; switch(v.getId())&#123; case R.id.btn_test: switch(event.getAction())&#123; case MotionEvent.ACTION_DOWN: Log.i(TAG, &quot;Button:ACTION_DOWN&quot;); break; case MotionEvent.ACTION_MOVE: Log.i(TAG, &quot;Button:ACTION_MOVE&quot;); break; case MotionEvent.ACTION_UP: Log.i(TAG, &quot;Button:ACTION_UP&quot;); break; &#125; return false; case R.id.custom_group: switch(event.getAction())&#123; case MotionEvent.ACTION_DOWN: Log.i(TAG, &quot;viewGroup:ACTION_DOWN&quot;); break; case MotionEvent.ACTION_MOVE: Log.i(TAG, &quot;viewGroup:ACTION_MOVE&quot;); break; case MotionEvent.ACTION_UP: Log.i(TAG, &quot;viewGroup:ACTION_UP&quot;); break; &#125; return false; &#125; return false; &#125;&#125; 我是这样响应的， 打印的log是 12345606-13 10:26:57.450 22708-22708/ALOG: viewGroup:ACTION_DOWN06-13 10:26:57.550 22708-22708/ALOG: viewGroup:ACTION_UP06-13 10:26:57.550 22708-22708/ALOG: viewGroup:onclick06-13 10:26:59.830 22708-22708/ALOG: Button:ACTION_DOWN06-13 10:26:59.920 22708-22708/ALOG: Button:ACTION_UP06-13 10:26:59.920 22708-22708/ALOG: Button:onclick 和上次几乎一样，那么我们改一改，我们在customViewGroup中添加了一个button 12345678910111213&lt;com.iscs.mobilewcs.customview.CustomViewGroup android:id=&quot;@+id/custom_group&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:clickable=&quot;true&quot;&gt; &lt;Button android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:id=&quot;@+id/btn_custom&quot; android:text=&quot;btn_custom&quot;/&gt; &lt;/com.iscs.mobilewcs.customview.CustomViewGroup&gt; 然后再来响应这个button的onclick和touch事件，customViewGroup中没有做任何改变。打印结果 12306-13 11:04:52.710 23390-23390/ALOG: btn_custom:ACTION_DOWN06-13 11:04:52.800 23390-23390/ALOG: btn_custom:ACTION_UP06-13 11:04:52.830 23390-23390/ALOG: btn_custom:onclick 可以响应btn_custom的响应事件，但是缺少了customViewGroup的响应时间， 因为cunstomViewGroup是包含这个button，为什么没有响应呢？那么我们做一下改变，重写customViewGroup中的onInterceptTouchEvent方法，这个方法其实就是ViewGroup事件分发有很大关系，ViewGroup事件分发也就比View事件分发多了这么一个方法。也就是ViewGroup事件分发一共有三个方法，分别是:onTouchEvent，dispatchTouchEvent，onInterceptTouchEvent 1234@Override public boolean onInterceptTouchEvent(MotionEvent ev) &#123; return super.onInterceptTouchEvent(ev); &#125; 我们先来看看这个方法里面有什么，查看源码 123public boolean onInterceptTouchEvent(MotionEvent ev) &#123; return false; &#125; 哈哈，你没有看错，就一个返回值，这是做了什么？我们看看文档怎么说的，我就用我渣渣的英语大改翻译一下For as long as you return false from this function, each following，event (up to and including the final up) will be delivered first here，and then to the target’s onTouchEvent()。If you return true from here, you will not receive any following events: the target view will receive the same event but with the action {@link MotionEvent#ACTION_CANCEL}, and all further events will be delivered to your onTouchEvent() method and no longer appear here。意思大概就是如果你返回false，事件会先传递到这儿，然后再到对应的onTouchEvent方法中，如果你返回true, 你将不会收到任何事件。我就能看懂这么多，哎，回头赶紧去学英语。意思上面已经表达清楚了，这个方法是有多么关键，因为默认返回false，那么我们重写返回true试试看。Log如下 12345606-13 11:31:18.810 13751-13751/ALOG: custom_group:ACTION_DOWN06-13 11:31:18.870 13751-13751/ALOG: custom_group:ACTION_UP06-13 11:31:18.870 13751-13751/ALOG: viewGroup:onclick06-13 11:31:21.760 13751-13751/ALOG: custom_group:ACTION_DOWN06-13 11:31:21.810 13751-13751/ALOG: custom_group:ACTION_UP06-13 11:31:21.810 13751-13751/ALOG: viewGroup:onclick 我点击了一下btn_custom和custom_group但是Log上只打印custom_group，纳尼，为什么呢？因为文档上已经写的很清楚了，当你返回true， 你将不会收到任何事件，我们来看看dispatchTouchEvent方法吧。 123456789101112131415161718192021222324if (disallowIntercept || !onInterceptTouchEvent(ev)) &#123; ev.setAction(MotionEvent.ACTION_DOWN); final int scrolledXInt = (int) scrolledXFloat; final int scrolledYInt = (int) scrolledYFloat; final View[] children = mChildren; final int count = mChildrenCount; for (int i = count - 1; i &gt;= 0; i--) &#123; final View child = children[i]; if ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) &#123; child.getHitRect(frame); if (frame.contains(scrolledXInt, scrolledYInt)) &#123; final float xc = scrolledXFloat - child.mLeft; final float yc = scrolledYFloat - child.mTop; ev.setLocation(xc, yc); child.mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT; if (child.dispatchTouchEvent(ev)) &#123; mMotionTarget = child; return true; &#125; &#125; &#125; &#125; &#125; 在dispathTouchEvent中有这么一个判断，他判断的是disallowIntercept和!onInterceptTouchEvent的返回值判断符是||, 我们刚才onInterceptTouchEvent返回值是true， 然而判断是onInterceptTouchEvent取反， 而disallowIntercept的默认值是false，两个都是false这个判断就进不来了，直接消耗掉了。我们在继续看源码，我们看到如果没有拦截，也就是返回false的时候，通过层层阻碍，到了这儿 1234567891011121314151617for (int i = count - 1; i &gt;= 0; i--) &#123; final View child = children[i]; if ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) &#123; child.getHitRect(frame); if (frame.contains(scrolledXInt, scrolledYInt)) &#123; final float xc = scrolledXFloat - child.mLeft; final float yc = scrolledYFloat - child.mTop; ev.setLocation(xc, yc); child.mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT; if (child.dispatchTouchEvent(ev)) &#123; mMotionTarget = child; return true; &#125; &#125; &#125; &#125; 上面代码判断viewgroup是否有子view，最后的 1234if (child.dispatchTouchEvent(ev)) &#123; mMotionTarget = child; return true; &#125; 如果有的话又调用的子View的dispathTouchEvent， 其实ViewGroup也是继承自View， 这样又转到了我们前几天写的第一篇View的事件分发。 #总结首先上一张总结图事件分发传递是先传到ViewGroup的，然后判断onInterceptTouchEvent的返回值，如果是false，继续向下传递，可以看成一个递归状态，但是如果是true，意味着拦截掉事件，然后响应dispathTouchEvent, 处理Touch事件。]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android事件的分发(一)]]></title>
    <url>%2F2017%2F07%2F26%2FAndroid%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%88%86%E5%8F%91(%E4%B8%80)%20%2F</url>
    <content type="text"><![CDATA[Android的事件分发是一个重点，同样也是一个难点，用到的地方非常的多，比如复杂的listview和srcoview嵌套， 带有侧拉功能的listView和viewPager相结合，listView下拉刷新和viewPager，很多个例子都是需要事件分发的，碰巧这个玩意又比较复杂，所以我们就来聊一聊Android的事件分发。 #View的事件分发 View事件的分发相对ViewGroup的分发来说还是比较简单的。我们先从View事件分发先来说起。上代码———-&gt; 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;Button android:id=&quot;@+id/btn_test&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;test_onTouch&quot; android:layout_centerInParent=&quot;true&quot;/&gt;&lt;/RelativeLayout&gt; xml布局很简单，就有一个button, 我们再来看java代码 12345678910111213141516171819202122232425262728293031323334353637383940public class MainActivity extends AppCompatActivity implements View.OnClickListener, OnTouchListener&#123; private static final String TAG = &quot;MainActivity&quot;; private Button btn_test; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initView(); &#125; public void initView()&#123; btn_test = (Button) findViewById(R.id.btn_test); btn_test.setOnClickListener(this); btn_test.setOnTouchListener(this); &#125; @Override public void onClick(View v) &#123; Log.i(TAG, &quot;onclick:btn_test&quot;); &#125; @Override public boolean onTouch(View v, MotionEvent event) &#123; switch(event.getAction())&#123; case MotionEvent.ACTION_DOWN: Log.i(TAG, &quot;ACTION_DOWN&quot;); break; case MotionEvent.ACTION_MOVE: Log.i(TAG, &quot;ACTION_MOVE&quot;); break; case MotionEvent.ACTION_UP: Log.i(TAG, &quot;ACTION_UP&quot;); break; &#125; return false; &#125;&#125; 我在点击事件上面和touch时间上面分别打上了tag，我们运行一下看看。 12306-07 14:33:08.458 25345-25345/MainActivity: ACTION_DOWN06-07 14:33:08.528 25345-25345/MainActivity: ACTION_UP06-07 14:33:08.528 25345-25345/MainActivity: onclick:btn_test 运行结果是down, up, onclick。意料之中。我们再看看上面的onTouch方法，如果把返回值改成true会发生什么？ 1206-07 14:51:06.638 25345-25345/MainActivity: ACTION_DOWN06-07 14:51:06.698 25345-25345/MainActivity: ACTION_UP 咦，好像少了一个LOG日志打印欸，What’s wrong? 这我们就得慢慢聊一聊onTouch这个方法。我们注册touch事件调用了这个方法setOnTouchListener(), 正如所有的可见控件都继承了view， 所以我们去直接去它的祖先类中view找setrOnTouchListener(), 我们看下Android2.2的源码，因为高版本的代码太多了，更复杂 不容易理解，所以我选择android2.2的源码。 123 public void setOnTouchListener(OnTouchListener l) &#123; mOnTouchListener = l; &#125; 找到了，和我们使用完全一样，传入一个OnTouchListener, 然后在内部赋值给mOnTouchListener， 其实mOnTouchListener是一个接口， 我们可以看到mOnTouchListener在dispathTouchEvent()方法中被调用到了， 我来说下这个dispathTouchEvent方法， 当我们触摸到手机上的控件的时候，会调用这个方法，dispatchTouchEvent()方法， 1234567 public boolean dispatchTouchEvent(MotionEvent event) &#123; if (mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; mOnTouchListener.onTouch(this, event)) &#123; return true; &#125; return onTouchEvent(event); &#125; 我们来观摩下mOnTouchListener里面的判断条件， mOnTouchListener！= null， 我们刚才看到mOntouchListener是什么东西了， 就是我们是否激活onTouchListener方法， 然后第二个条件(mViewFlags &amp; ENABLED_MASK) == ENABLED这个说白了就是空间是否是可用的，肯定是true， 最后这个条件mOnTouchListener.onTouch(this, event)， 是不是有点面熟， mOnTouchListener中的onTouch方法， 刚才有说过mOnTouchListener是个接口， 那么我们实现了这个方法的时候重写了该方法，关键就是它的返回值了，我们刚才测试， 如果返回值为true， 那么我们的onclick事件就不会响应了，这意味着该事件被消耗掉了。所以，当这三个条件都满足的时候返回true, 反之 调用onTouchEvent， 那么我们继续看看onTouchEvent方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192 public boolean onTouchEvent(MotionEvent event) &#123; final int viewFlags = mViewFlags; if ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123; // A disabled view that is clickable still consumes the touch // events, it just doesn&apos;t respond to them. return (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)); &#125; if (mTouchDelegate != null) &#123; if (mTouchDelegate.onTouchEvent(event)) &#123; return true; &#125; &#125; if (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_UP: boolean prepressed = (mPrivateFlags &amp; PREPRESSED) != 0; if ((mPrivateFlags &amp; PRESSED) != 0 || prepressed) &#123; // take focus if we don&apos;t have it already and we should in // touch mode. boolean focusTaken = false; if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123; focusTaken = requestFocus(); &#125; if (!mHasPerformedLongPress) &#123; // This is a tap, so remove the longpress check removeLongPressCallback(); // Only perform take click actions if we were in the pressed state if (!focusTaken) &#123; // Use a Runnable and post this rather than calling // performClick directly. This lets other visual state // of the view update before click actions start. if (mPerformClick == null) &#123; mPerformClick = new PerformClick(); &#125; if (!post(mPerformClick)) &#123; performClick(); &#125; &#125; &#125; if (mUnsetPressedState == null) &#123; mUnsetPressedState = new UnsetPressedState(); &#125; if (prepressed) &#123; mPrivateFlags |= PRESSED; refreshDrawableState(); postDelayed(mUnsetPressedState, ViewConfiguration.getPressedStateDuration()); &#125; else if (!post(mUnsetPressedState)) &#123; // If the post failed, unpress right now mUnsetPressedState.run(); &#125; removeTapCallback(); &#125; break; case MotionEvent.ACTION_DOWN: if (mPendingCheckForTap == null) &#123; mPendingCheckForTap = new CheckForTap(); &#125; mPrivateFlags |= PREPRESSED; mHasPerformedLongPress = false; postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout()); break; case MotionEvent.ACTION_CANCEL: mPrivateFlags &amp;= ~PRESSED; refreshDrawableState(); removeTapCallback(); break; case MotionEvent.ACTION_MOVE: final int x = (int) event.getX(); final int y = (int) event.getY(); // Be lenient about moving outside of buttons int slop = mTouchSlop; if ((x &lt; 0 - slop) || (x &gt;= getWidth() + slop) || (y &lt; 0 - slop) || (y &gt;= getHeight() + slop)) &#123; // Outside button removeTapCallback(); if ((mPrivateFlags &amp; PRESSED) != 0) &#123; // Remove any future long press/tap checks removeLongPressCallback(); // Need to switch from pressed to not pressed mPrivateFlags &amp;= ~PRESSED; refreshDrawableState(); &#125; &#125; break; &#125; return true; &#125; return false; &#125; 看完刚才那个方法再看这个，是不是感觉突然代码量大多了，不过没关系，我们只需要看这个条件判断下的就好了if (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE))判断成立后直接进入switch语句中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071switch (event.getAction()) &#123; case MotionEvent.ACTION_UP: boolean prepressed = (mPrivateFlags &amp; PREPRESSED) != 0; if ((mPrivateFlags &amp; PRESSED) != 0 || prepressed) &#123; // take focus if we don&apos;t have it already and we should in // touch mode. boolean focusTaken = false; if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123; focusTaken = requestFocus(); &#125; if (!mHasPerformedLongPress) &#123; // This is a tap, so remove the longpress check removeLongPressCallback(); // Only perform take click actions if we were in the pressed state if (!focusTaken) &#123; // Use a Runnable and post this rather than calling // performClick directly. This lets other visual state // of the view update before click actions start. if (mPerformClick == null) &#123; mPerformClick = new PerformClick(); &#125; if (!post(mPerformClick)) &#123; performClick(); &#125; &#125; &#125; if (mUnsetPressedState == null) &#123; mUnsetPressedState = new UnsetPressedState(); &#125; if (prepressed) &#123; mPrivateFlags |= PRESSED; refreshDrawableState(); postDelayed(mUnsetPressedState, ViewConfiguration.getPressedStateDuration()); &#125; else if (!post(mUnsetPressedState)) &#123; // If the post failed, unpress right now mUnsetPressedState.run(); &#125; removeTapCallback(); &#125; break; case MotionEvent.ACTION_DOWN: if (mPendingCheckForTap == null) &#123; mPendingCheckForTap = new CheckForTap(); &#125; mPrivateFlags |= PREPRESSED; mHasPerformedLongPress = false; postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout()); break; case MotionEvent.ACTION_CANCEL: mPrivateFlags &amp;= ~PRESSED; refreshDrawableState(); removeTapCallback(); break; case MotionEvent.ACTION_MOVE: final int x = (int) event.getX(); final int y = (int) event.getY(); // Be lenient about moving outside of buttons int slop = mTouchSlop; if ((x &lt; 0 - slop) || (x &gt;= getWidth() + slop) || (y &lt; 0 - slop) || (y &gt;= getHeight() + slop)) &#123; // Outside button removeTapCallback(); if ((mPrivateFlags &amp; PRESSED) != 0) &#123; // Remove any future long press/tap checks removeLongPressCallback(); // Need to switch from pressed to not pressed mPrivateFlags &amp;= ~PRESSED; refreshDrawableState(); &#125; &#125; 这里面有几个状态， 我们想一下刚才打印的log， 首先是down, 其次是up， 最后才是onclick， 那我们找一下up，performClick(); 咦， 这是什么方法？好可疑，我们点进去看看 123456789 public boolean performClick() &#123; sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED); if (mOnClickListener != null) &#123; playSoundEffect(SoundEffectConstants.CLICK); mOnClickListener.onClick(this); return true; &#125; return false; &#125; 有特么看到mOnclickListener了，阴魂不散啊， 这次判断就很简单了，只要mOnclickListner ！= null就会调用它的onClick方法，返回true。看到这儿是不是瞬间脑动大开了，哈哈，把我累够呛。 最后在上一张流程图。]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AndroidSocketClient开源库的使用]]></title>
    <url>%2F2017%2F07%2F26%2FAndroidSocketClient%E5%BC%80%E6%BA%90%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8%20%2F</url>
    <content type="text"><![CDATA[我发现网上关于socket的库介绍比较少啊，难道socket太简单了，大家不喜欢做？哈哈哈 我给大家推荐一个socketclient库，用起来特别方便，主要是源于前几天公司需要长连接，正好逛GitHub的时候发现的这个库，挺爽挺方便的，推荐给大家。 git:https://github.com/vilyever/AndroidSocketClient 下载完导入，然后再gradle中添加 repositories { maven { url &quot;https://jitpack.io&quot; } } dependencies { compile &apos;com.github.vilyever:AndroidSocketClient:1.4.1&apos; } 至于用法也是非常简单 private SocketClient socketClient; 创建scoketClient. socketClient = new SocketClient(url, prot); 里面传入socketClient的url地址和端口号。 socketClient.registerSocketDelegate(new SocketClient.SocketDelegate(){ @Override public void onConnected(SocketClient client) { socketClient.send(&quot;hello, server !---------------------------&gt;Android&quot;); socketClient.setHeartBeatMessage(&quot;hello, server !---------------------------&gt;Android&quot;); } @Override public void onDisconnected(SocketClient client) { Log.i(&quot;Server&quot;, &quot;timeout&quot;); String error = client.getCharsetName(); Log.i(&quot;Server&quot;, &quot;timeoutData:&quot;+error); } @Override public void onResponse(SocketClient client, @NonNull SocketResponsePacket responsePacket) { String responseMsg = responsePacket.getMessage(); int i = 1; Log.i(&quot;Server&quot;, responseMsg); } }); 这个方法直接实现了socket发送信息到服务器，在onDisconnected()错误信息也可以及时返回并打印。 socketClient.setConnectionTimeout(1000 * 15); socketClient.setHeartBeatInterval(1000); socketClient.setRemoteNoReplyAliveTimeout(1000 * 60); socketClient.setCharsetName(&quot;UTF-8&quot;); socketClient.connect(); 这边设置的是超时时间，心跳包的间隔， 自动连接时间，编码格式。是不是用起来特别爽？因为库也是国人写的，注释都是中文，大家可以扒一扒源代码看如何实现， 毕竟学东西不只是学如何使用，还要追求原理的。]]></content>
      <tags>
        <tag>Library</tag>
      </tags>
  </entry>
</search>